---
layout: post
title: One reason to prioritize the feature work over tech work
date: 2020-02-09 12:40 +0200
tags: []
categories: []
---

A couple of weeks ago I wrote about the [P/PC Balance][1], and while thinking about it some more, a kind of comic realization stroke me: I realized that one good reason to prioritize feature work above technical work on a project is that the former is _finite_, while the latter is potentially _infinite_.

[1]: {% post_url 2020-01-25-planning-tip-p-pc-balance %}


For example if I want to implement a login page, there is only so much I would want for a relatively complete MVP: the form with a couple of fields, maybe some related navigation links, and I after that I can hardly think of a lot of important things to add that would make it considerably more valuable for the users.

Compare that with the technical aspects that can go around the login page: I can try to get the perfect semantic HTML5 markup to implement it, the perfect ARIA roles for the UI elements, the perfect way to do CSS layout, the perfect way to budle the front-end code, etc.; and that’s only on the front-end. I can imagine as many ways to encode the form data to send to the server-side of things, ways to validate and store the data in the back-end, get the perfect type-checking between the two sides, and many more.

I find that I can be especially tempted to look for this kind of “perfection” on a project of my own, this can be in fact one of the reasons why I start to work on an own project: to exercise the decision skills that I can’t at work, and have the quality of code that I can share with excitement and pride on GitHub.

— _But_, the engineer im me would say, _wouldn’t then prioritizing feature work rob me of fulfilling all of these dear engineering needs of mine!?_

Well, I think it depends on what my intention is for the project: if that’s purely play and exploration of a cool new tech, maybe I’d allow me to fiddle indefinitely with it, and wouldn’t feel guilty about it. But if the intent is to get something out to the users, then _that_ would be the source of enjoyment and the measure of success, and in that context I expect to not be as upset with a yet imperfect implementation, as long as it’s good enough to allow me to move towards my goal.

So, in the end, it seems that it comes down to having the clear goals for the project, and prioritizing the kinds of work accordingly.
